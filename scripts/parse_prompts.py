import re
import os

def parse_prompts(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Pattern to match:
    # <summary><strong>Title</strong></summary>
    # ...
    # ```md (or just ```)
    # Prompt Content
    # ```
    
    # Regex explanation:
    # <summary><strong>(.*?)</strong></summary>  -> Capture Title
    # .*?                                        -> Match anything non-greedy until code block
    # ```(?:md)?\s*\n                            -> Match start of code block (``` or ```md)
    # (?s)(.*?)                                  -> Capture content (dot matches newline)
    # \n```                                      -> Match end of code block
    
    pattern = re.compile(r'<summary><strong>(.*?)</strong></summary>.*?```(?:md|csv)?\s*\n(.*?)\n```', re.MULTILINE | re.DOTALL)
    
    matches = pattern.findall(content)
    prompts = []
    
    print(f"Found {len(matches)} prompts.")
    
    for title, prompt_content in matches:
        # Clean content
        prompt_content = prompt_content.strip()
        
        # Escape single quotes for SQL
        safe_content = prompt_content.replace("'", "''")
        safe_title = title.strip().replace("'", "''")
        
        # Generate Preview (first 100 chars)
        preview = safe_content[:150].replace('\n', ' ') + "..."
        
        # Determine Type
        prompt_type = "System Prompt"
        lower_content = prompt_content.lower()
        if "act as" in lower_content or "act like" in lower_content:
            prompt_type = "Roleplay"
        elif "write" in lower_content or "generate" in lower_content:
            prompt_type = "Chain-of-Thought" # Heuristic
            
        # Determine Tags from Title
        tags = [word for word in title.split() if len(word) > 3]
        tags = [t.replace("'", "") for t in tags]
        
        # Format as SQL Value
        # (title, preview, content, type, model, tokens, rating, rating_count, fork_count, tags, author_name)
        
        # Fake stats
        rating = 4.5
        rating_count = 10
        fork_count = 5
        tokens = len(prompt_content.split()) * 1.3 # Rough estimate
        
        if not tags:
            tags_sql = "ARRAY[]::text[]"
        else:
            tags_sql = "ARRAY[" + ", ".join([f"'{t}'" for t in tags]) + "]"
        
        sql_value = f"""(
    '{safe_title}', 
    '{preview}', 
    '{safe_content}', 
    '{prompt_type}', 
    'GPT-4', 
    {int(tokens)}, 
    {rating}, 
    {rating_count}, 
    {fork_count}, 
    {tags_sql},
    'Community'
)"""
        prompts.append(sql_value)

    return prompts

def generate_sql(prompts, output_dir):
    CHUNK_SIZE = 300
    total_prompts = len(prompts)
    
    # Chunk the prompts
    for i in range(0, total_prompts, CHUNK_SIZE):
        chunk_num = (i // CHUNK_SIZE) + 1
        chunk_prompts = prompts[i : i + CHUNK_SIZE]
        
        filename = f"20260111_seed_public_prompts_part_{chunk_num}.sql"
        output_file = os.path.join(output_dir, filename)
        
        header = f"""-- =====================================================
-- Seed Public Prompts (Part {chunk_num})
-- Generated by Antigravity
-- =====================================================
"""
        # Only truncate in the first part
        if chunk_num == 1:
            header += "\nTRUNCATE public_prompts;\n"

        header += "\nINSERT INTO public_prompts (title, preview, content, type, model, tokens, rating, rating_count, fork_count, tags, author_name) VALUES\n"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(header)
            f.write(",\n".join(chunk_prompts))
            f.write(";\n")
        
        print(f"Generated {output_file} ({len(chunk_prompts)} rows)")

if __name__ == "__main__":
    input_path = r"c:\Users\Vignesh\Documents\Work TILL DONE\Prompt Library\PROMPTS.md"
    # Output to migrations dir
    output_dir = r"c:\Users\Vignesh\Documents\Work TILL DONE\Prompt Library\supabase\migrations"
    
    prompts = parse_prompts(input_path)
    if prompts:
        generate_sql(prompts, output_dir)
    else:
        print("No prompts found! Check regex.")
